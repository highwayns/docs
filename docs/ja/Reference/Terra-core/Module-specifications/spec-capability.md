# 能力

:::警告メモ
Terraの機能モジュールは、Cosmos SDKの[`capability`](https://docs.cosmos.network/master/modules/capability/)モジュールから継承されます。このドキュメントはスタブであり、主にその使用方法に関する重要なTerra固有の手順をカバーしています。
:::

機能モジュールを使用すると、実行時に複数所有者の機能を構成、追跡、および検証できます。

Keeperは、永続メモリと短期メモリの2つの状態を維持します。永続状態は、グローバルに一意の自動インクリメントインデックスと、機能インデックスからモジュール名と機能名のタプルとして定義された機能所有者のセットへのマッピングを維持します。一時メモリステータスは、ローカルメモリ内のアドレスとして表される実際の機能を、順方向および逆方向のインデックスで追跡します。フォワードインデックスは、モジュール名と機能タプルを機能名にマップします。転置インデックスは、モジュール名と関数名を関数自体にマップします。

Keeperを使用すると、スコープ付きサブマネージャーを作成できます。サブマネージャーは、名前で特定のモジュールにバインドされます。アプリケーションを初期化するときは、スコープサブ管理者を作成してモジュールに渡す必要があります。モジュールは、それらを使用して、受け取った関数を宣言し、名前で持っている関数を取得できます。さらに、新しい関数を作成し、他のモジュールから渡された関数を検証できます。スコープ付きサブキーパーはスコープを離れることができないため、モジュールが他のモジュールの機能に干渉したり、その機能をチェックしたりすることはできません。

Keeperは、クエリャー、RESTおよびCLIハンドラー、作成ステータスなど、他のモジュールにある他のコア機能を提供しません。

## 初期化

アプリケーションを初期化するとき、キーパーは永続ストレージキーと一時メモリストレージキーを使用してインスタンス化する必要があります。

```
type App struct {
 //...

  capabilityKeeper *capability.Keeper
}

func NewApp(...) *App {
 //...

  app.capabilityKeeper = capability.NewKeeper(codec, persistentStoreKey, memStoreKey)
}
```

Keeperが作成されると、スコープ付きサブキーパーを作成できます。これらのサブキーパーは、関数を作成、検証、および宣言できる他のモジュールに渡されます。 必要なすべてのスコープサブキーパーを作成して状態をロードした後、メイン関数キーパーを初期化してシールし、一時メモリ状態を埋めて、スコープサブキーパーがさらに作成されないようにする必要があります。

```
func NewApp(...) *App {
 //...

 //Initialize and seal the capability keeper so all persistent capabilities
 //are loaded in-memory and prevent any further modules from creating scoped
 //sub-keepers.
  ctx := app.BaseApp.NewContext(true, tmproto.Header{})
  app.capabilityKeeper.InitializeAndSeal(ctx)

  return app
}
```

## 概念

機能は複数所有者です。スコープのサブ管理者は、「NewCapability」を介して機能を作成できます。これにより、偽造不可能な一意のオブジェクト機能参照が作成されます。新しく作成された関数は自動的に保持されます。呼び出し側モジュールは `ClaimCapability`を呼び出す必要はありません。 「NewCapability」を呼び出すと、モジュールを呼び出す機能が作成され、その名前がタプルとして機能の最初の所有者になります。

他のモジュールは関数を宣言でき、これらのモジュールはそれらを所有者として追加します。 `ClaimCapability`を使用すると、モジュールは別のモジュールから受け取ったファンクションキーを宣言できるため、後で` GetCapability`を呼び出すことができます。機能を受け取ったモジュールが将来名前でアクセスしたい場合は、 `ClaimCapability`を呼び出す必要があります。機能は複数所有者であるため、複数のモジュールに機能参照がある場合、すべてのモジュールにそれがあります。モジュールが別のモジュールから機能を受け取ったが、 `ClaimCapability`を呼び出さなかった場合、そのモジュールはトランザクションの実行にそれを使用できますが、後でアクセスすることはできません。

どのモジュールも「AuthenticateCapability」を呼び出して、モジュールを呼び出す前に、その名前に関連付けられている信頼できないユーザー入力など、関数が特定の名前に対応しているかどうかを確認できます。

`GetCapability`を使用すると、モジュールは以前に名前で宣言した機能を取得できます。モジュールは、モジュールに属していない関数を取得することはできません。

### Stores

- MemStore

## States

- Index
- CapabilityOwners
- Capability
